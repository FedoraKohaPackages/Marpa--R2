# Copyright 2014 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2::Event - SLIF parse events

=head1 Synopsis

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1
partial: 1

    my $input = q{a b c "insert d here" e e f};
    my $length = length $input;
    my $pos    = $slr->read( \$input );

    my $actual_events = q{};

    READ: while (1) {

        my @actual_events = ();

        my $next_lexeme;
        EVENT:
        for my $event ( @{ $slr->events() } ) {
            my ($name) = @{$event};

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1
partial: 1

            push @actual_events, $name;
        }

        if (@actual_events) {
            $actual_events .= join q{ }, "Events at position $pos:", @actual_events;
            $actual_events .= "\n";
        }

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1
partial: 1

        if ($pos < $length) {
            $pos = $slr->resume();
            next READ;
        }
        last READ;
    } ## end READ: while (1)

=for Marpa::R2::Display::End

The synopsis is extracted from an example given in full
L<below|/"An example">.

=head1 About this document

This document is an overview of B<SLIF parse events>.
The purpose of SLIF parse events is to interrupt SLIF
internal parsing, or "B<trigger>", based on "B<events>" chosen
by the application.
The events available
include things as the prediction or recognition
of symbols.

SLIF parse events are often used to enable the application to
switch over to its own custom procedural logic.
Among other things,
an application can do its own "external" scanning of lexemes.
An application may ask Marpa to resume internal scanning at
any point.

SLIF parse events may be named or unnamed.
Use of unnamed events is discouraged, and should be reserved for legacy
code.
New applications should only use named events.
When not otherwise specified,
this document is talking about named events.
Unnamed events are described
L<below,
in a section dedicated to them|/"Unnamed events">.

SLIF parse events are called B<parse events>
or simply B<events>,
in contexts where the meaning is clear.

SLIF parse events evolved over time from simpler
mechanisms,
and the term SLIF parse event was introduced late
in the development of Marpa::R2.
In previous versions of Marpa::R2,
SLIF parse events and their precursors are called "pauses" or simply "events".
For historical reasons,
some of the method names dealing with SLIF parse events
still have the word "pause" as part of their name.

=head1 The life cycle of events

Events are first B<declared>.
A declared event may B<trigger>.
Once an event triggers, it may be B<accessed>.

Events are declared in the SLIF DSL.
Parse events can be either a lexeme event
or a non-lexeme event.
Lexeme events are declared using
L<a C<:lexeme> pseudo-rules|Marpa::R2::DSL/"Lexeme pseudo-rules">.
Non-lexeme events are declared using
L<named event statements|Marpa::R2::DSL/"Named event statement">.
The various kinds of parse events are described in detail below.
For each type of parse event,
its descriptions
will indicate whether it is a lexeme or a non-lexeme event.

Once declared, events
may trigger during any event-triggering SLIF
recognizer method.
When an event triggers, it causes the event-triggering
method to return immediately, with the current location
at the B<trigger point>.
The event-triggering SLIF recognizer methods are
L<C<read()>|Marpa::R2::Scanless::R/"read()">,
L<C<resume()>|Marpa::R2::Scanless::R/"resume()">,
L<C<lexeme_read()>|Marpa::R2::Scanless::R/"lexeme_read()"> and
L<C<lexeme_complete()>|Marpa::R2::Scanless::R/"lexeme_complete()">.
Non-lexeme events may trigger during any of the event-triggering
methods.
Lexeme events will only trigger during calls of the
C<< $slr->read() >> and C<< $slr->resume() >> methods.

When an event triggers, it causes the method
to return immediately, leaving the current location at the location
at which the event triggered -- its B<trigger location>.
Events may be accessed using
L<the Scanless recognizer's events()
method|/"events()">.
The beginning and end of the lexeme triggering a lexeme event
may be found using
L<the Scanless recognizer's pause_span()
method|/"pause_span()">.

Applications need to be aware of a special case:
SLIF parse events may trigger at a location at which the method
would return in any case.
For example, the C<< $slr->read() >> method always returns
at end of string.
But an event may have triggered at the end of string as well.
The code in the synopsis is carefully written to catch
events which trigger at end of string.
Normally, you end the read loop at end of string,
and applications which do not use parse events may do this.
But the code above, after an the end of string is reached,
makes one additional
pass through the 
event-reading logic, in order to report any events which
occurred at end of string.

=head1 Types of parse event

=head2 Completion events

Completion events are declared in the SLIF DSL
using the
L<named event statement|Marpa::R2::DSL/"Named event statement">:

=for Marpa::R2::Display
name: SLIF completed event statement synopsis
partial: 1
normalize-whitespace: 1

    event subtext = completed <subtext>

=for Marpa::R2::Display::End

A completion event triggers
whenever a rule with its symbol on
its LHS is fully recognized in the parse.
(The idea is that "symbol completion" occurs when the
rule, and therefore its LHS, is "complete".)
The trigger location is the end location
of the triggering symbol instance.

Completion SLIF parse events can be specifed for any
symbol that is not a lexeme.
Completion events are non-lexeme events.

As a special case,
a completion event is never triggered by any
zero-length instance of a symbol.
Nulled symbols
may only be detected as nulling events --
they will never trigger completion events.

=head2 Nulling events

Nulling events are declared in the SLIF DSL
using the
L<named event statement|Marpa::R2::DSL/"Named event statement">:

=for Marpa::R2::Display
name: SLIF nulled event statement synopsis
partial: 1
normalize-whitespace: 1

    event 'A[]' = nulled <A>

=for Marpa::R2::Display::End

A nulling SLIF parse event occurs whenever a zero-length symbol instance
of its symbol is recognized.
The trigger location is the location of the triggering symbol instance --
the location where the nulled symbol both begins and ends.

Nulling SLIF parse events can be specifed for any
symbol that is not a lexeme.
Nulling events are non-lexeme events.

Nulled symbols may derive other null symbols,
and null derivations may be ambiguous.
All nulling events for symbols in these derivations will
trigger if they are declared.
More precisely,

=over 4

=item * If the grammar allows
any derivation of the symbol
I<Y> from I<X> in which I<X> and I<Y> are both
nulled; and

=item * a nulling
SLIF parse event is declared for I<Y>; and

=item * a nulled instance of I<X> is encountered
in the parse at location I<L>; then

=item * a nulling SLIF parse event for I<Y>
will trigger at location I<L>.

=back

Nulling events and completion events are mutually exclusive.
A nulled, or zero-length, symbol will never trigger a
prediction event or a completion event.
And any symbol recognized or predicted
at greater than zero-length will never trigger
a nulling event, so that
no symbol instance which triggers either a prediction
event or a completion event will also
trigger a nulling event.

=head2 Prediction events

Prediction events are declared in the SLIF DSL
using the
L<named event statement|Marpa::R2::DSL/"Named event statement">:

=for Marpa::R2::Display
name: SLIF predicted event statement synopsis
partial: 1
normalize-whitespace: 1

    event '^a' = predicted A

=for Marpa::R2::Display::End

A prediction event occurs at any location where a non-zero-length
instance of its
symbol would be accepted by the recognizer.
The trigger location is the location of the prediction --
the location at which that instance of the triggering symbol
would begin, if it actually does occur in the input.

Prediction SLIF parse events may be defined for any symbol,
whether it is a lexeme or not.
But prediction events are always non-lexeme events,
even if their symbol is a lexeme.

As a special case, a symbol which is only predicted as a
zero-length symbol does B<not> trigger a prediction event.
This is because
there is no practical distinction between expecting
a zero-length symbol, and actually seeing one.
Zero-length symbols are always regarded as actually being
recognized as soon as they are predicted, and
they never generate prediction events,
only nulling events.

=head2 After-lexeme events

An after-lexeme event is a lexeme event.

=head2 Before-lexeme events

An before-lexeme event is a lexeme event.
A before-lexeme event is B<not>
the same as
a prediction event of a symbol which is a lexeme,
although the two may occur at once.
A before-lexeme event does not occur unless that the lexeme is actually
found in the input.
A prediction event, on the other hand, is
as the name suggests, only a prediction.
The predicted symbol may or not actually be found in the input.

=head1 Techniques

=head2 Markers

It is quite reasonable to create "markers" --
nulling symbols
whose primary (or sole) purpose
is to have nulling events declared for them.
Markers are the only way to declare events that trigger in
the middle of rule.

=head2 Rules

There are no events explicitly defined in terms of rules,
but every rule event that is wanted can be achieved in
one or more ways.
The most flexible of these, and the best for most purposes,
is to use L<markers|/"Markers">.

Another method is to use the LHS of a rule to track rule
predictions and completions.
This requires that the LHS symbol of the rule be unique to that
rule.

=head1 Implications

Some of the implications of the way events work will be found,
at first, to be unexpected.
This section contains potential surprises,
show that they are Marpa working as designed.
I also hope readers will also find these behaviors, 
if at first unexpected,
are desirable.

=head1 An example

The SLIF DSL in this example
is unlike anything you would actually
use in practice.
It
is intended to illusrate the unusual and "corner" cases
described above.

=for Marpa::R2::Display
name: SLIF events() method synopsis
normalize-whitespace: 1

    sub forty_two { return 42; };

    use Marpa::R2;

    my $dsl = <<'END_OF_DSL';
    :default ::= action => [name,values]
    lexeme default = latm => 1

    test ::= a b c d e e f action => main::forty_two
        | a ambig1 | a ambig2
    e ::= <real e> | <null e>
    <null e> ::=
    d ::= <real d> | <insert d>
    ambig1 ::= start1 mid1 z
    ambig2 ::= start2 mid2 z
    start1 ::= b  mid1 ::= c d
    start2 ::= b c  mid2 ::= d

    a ~ 'a' b ~ 'b' c ~ 'c'
    <real d> ~ 'd'
    <insert d> ~ ["] 'insert d here' ["]
    <real e> ~ 'e'
    f ~ 'f'
    z ~ 'z'

    :lexeme ~ <a> pause => after event => '"a"'
    :lexeme ~ <b> pause => after event => '"b"'
    :lexeme ~ <c> pause => after event => '"c"'
    :lexeme ~ <real d> pause => after event => '"d"'
    :lexeme ~ <insert d> pause => before event => 'insert d'
    :lexeme ~ <real e> pause => after event => '"e"'
    :lexeme ~ <f> pause => after event => '"f"'

    event '^test' = predicted test
    event 'test$' = completed test
    event '^start1' = predicted start1
    event 'start1$' = completed start1
    event '^start2' = predicted start2
    event 'start2$' = completed start2
    event '^mid1' = predicted mid1
    event 'mid1$' = completed mid1
    event '^mid2' = predicted mid2
    event 'mid2$' = completed mid2

    event '^a' = predicted a
    event '^b' = predicted b
    event '^c' = predicted c
    event 'd[]' = nulled d
    event 'd$' = completed d
    event '^d' = predicted d
    event '^e' = predicted e
    event 'e[]' = nulled e
    event 'e$' = completed e

    :discard ~ whitespace
    whitespace ~ [\s]+
    END_OF_DSL

    my $grammar = Marpa::R2::Scanless::G->new( { source => \$dsl } );
    my $slr = Marpa::R2::Scanless::R->new(
        { grammar => $grammar, semantics_package => 'My_Actions' } );
    my $input = q{a b c "insert d here" e e f};
    my $length = length $input;
    my $pos    = $slr->read( \$input );

    my $actual_events = q{};

    READ: while (1) {

        my @actual_events = ();

        my $next_lexeme;
        EVENT:
        for my $event ( @{ $slr->events() } ) {
            my ($name) = @{$event};
            if ($name eq 'insert d') {
               my (undef, $length) = $slr->pause_span();
               $next_lexeme = ['real d', 'd', $length];
            }
            push @actual_events, $name;
        }

        if (@actual_events) {
            $actual_events .= join q{ }, "Events at position $pos:", @actual_events;
            $actual_events .= "\n";
        }

        if ($next_lexeme) {
            $slr->lexeme_read(@{$next_lexeme});
            $pos = $slr->pos();
            next READ;
        }
        if ($pos < $length) {
            $pos = $slr->resume();
            next READ;
        }
        last READ;
    } ## end READ: while (1)

    my $expected_events = <<'=== EOS ===';
    Events at position 0: ^test ^a
    Events at position 1: "a" ^b ^start1 ^start2
    Events at position 3: "b" start1$ ^c ^mid1
    Events at position 5: "c" start2$ ^d ^mid2
    Events at position 6: insert d
    Events at position 21: d$ mid1$ mid2$ e[] ^e
    Events at position 23: "e" e$ e[] ^e
    Events at position 25: "e" e$
    Events at position 27: "f" test$
    === EOS ===

=for Marpa::R2::Display::End

=head1 Unnamed events

Use of unnamed events is strongly discouraged.
However, to support legacy code, unnamed events are still supported
and are still described in this documentation.

Unnamed events are defined in
L<C<:lexeme> pseudo-rules|Marpa::R2::Scanless::DSL/"Lexeme pseudo-rules">,
when
L<the C<pause> adverb|Marpa::R2::Scanless::DSL/"pause"> 
is used without an
L<the C<event> adverb|Marpa::R2::Scanless::DSL/"event">.
(The C<pause> adverb is so named, because
Marpa's SLIF parse events were once called ``pauses''.)
Since the
L<the C<pause> adverb|Marpa::R2::Scanless::DSL/"pause">
does create a SLIF parse event, but
it is the
L<the C<event> adverb|Marpa::R2::Scanless::DSL/"event">
that provide the name for the SLIF parse event,
this results in an event without a name --
an unnamed event.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2014 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# vim: expandtab shiftwidth=4:
